
### Содержание статьи

- [Для чего нужен Secure Boot](https://xakep.ru/2019/12/25/protec-stm32/#toc01.)
- [Как это работает](https://xakep.ru/2019/12/25/protec-stm32/#toc02.)
- [Аппаратные средства](https://xakep.ru/2019/12/25/protec-stm32/#toc03.)
- [Защита от чтения, RDP](https://xakep.ru/2019/12/25/protec-stm32/#toc03.1)
- [Защита от записи, WRP](https://xakep.ru/2019/12/25/protec-stm32/#toc03.2)
- [Только исполнение, PCROP](https://xakep.ru/2019/12/25/protec-stm32/#toc03.3)
- [Безопасный доступ, SAO](https://xakep.ru/2019/12/25/protec-stm32/#toc03.4)
- [Блок защиты памяти, MPU](https://xakep.ru/2019/12/25/protec-stm32/#toc03.5)
- [Обнаружение воздействия, Anti-Tamper](https://xakep.ru/2019/12/25/protec-stm32/#toc03.6)
- [Сторожевой таймер, IWDG](https://xakep.ru/2019/12/25/protec-stm32/#toc03.7)
- [Внешний флеш](https://xakep.ru/2019/12/25/protec-stm32/#toc03.8)
- [Криптография](https://xakep.ru/2019/12/25/protec-stm32/#toc04.)
- [Пользовательская схема шифрования](https://xakep.ru/2019/12/25/protec-stm32/#toc04.1)
- [Реализация для H743](https://xakep.ru/2019/12/25/protec-stm32/#toc05.)
- [Image\_SECoreBin](https://xakep.ru/2019/12/25/protec-stm32/#toc05.1)
- [Image\_SBSFU](https://xakep.ru/2019/12/25/protec-stm32/#toc05.2)
- [Image\_UserApp](https://xakep.ru/2019/12/25/protec-stm32/#toc05.3)
- [Прошивка и настройка Option Bytes](https://xakep.ru/2019/12/25/protec-stm32/#toc05.4)
- [Заключение](https://xakep.ru/2019/12/25/protec-stm32/#toc06.)
## Для чего нужен Secure Boot

В общем случае разработчику, который хочет защитить свое устройство, предстоит решить две ключевые задачи.

- В первую очередь следует реализовать механизм подтверждения подлинности прошивки (аутентификации). Для этого используются различные криптографические алгоритмы (например, SHA-256 и NIST P256). Они позволяют убедиться, что на устройстве будет исполняться только доверенный код.
- Кроме того, необходимо защитить память от внешних атак и лишить злоумышленника доступа к критичным регионам, который он может в теории получить с помощью уязвимостей ПО либо при использовании отладочных интерфейсов (например, JTAG) или логического анализатора.

Итак, это два разных механизма защиты и преследуют они разные цели, но только их совместное применение позволяет эффективно бороться с угрозами. Иными словами, даже самые совершенные криптографические алгоритмы окажутся бесполезными, если хакер может получить расшифрованный дамп прошивки. И наоборот, защищенная от считывания память никак не предотвратит загрузку программы с вредоносным кодом.

## Как это работает

Сегодня самый простой способ обновить прошивку устройства (SFU, Secure Firmware Update) — это отправить ему свежую версию удаленно, «по воздуху». Таким образом, мы храним на сервере и распространяем уже зашифрованный бинарник, который клиент может скачать, подтвердить его целостность, аутентифицировать, расшифровать и, наконец, установить.

![](https://xakep.ru/wp-content/uploads/2019/12/257286/VerificationEncription.png)

Базовую безопасность при этом обеспечивают следующие меры: во-первых, исключается возможность альтернативных методов загрузки. Для этого применяется подтвержденный Secure Boot, который формирует root of trust в нашей системе. Во-вторых, приватные ключи шифрования должны храниться в прошивке устройства и быть индивидуальными.

![](https://xakep.ru/wp-content/uploads/2019/12/257286/RootOfTrust.png)

Кроме того, конкретную реализацию криптографического алгоритма следует проверять на устойчивость к АВК (атака по второстепенным каналам, side-channel attack) или АМИС (атака методом индуцированных сбоев, fault injection attack). К этому мы еще вернемся.

Наконец, следует озаботиться защитой от нежелательного внешнего доступа. К счастью, многие разработчики уже научились отключать JTAG — самый желанный подарок для злоумышленника. Однако производители не стоят на месте и предлагают сегодня дополнительные средства обнаружить воздействие, такие как Anti-Tamper. Ими пользуются пока не так часто, как хотелось бы.

## Аппаратные средства

Посмотрим теперь, как выглядит применение подобных рекомендаций на практике, для линейки микроконтроллеров STM32.

![](https://xakep.ru/wp-content/themes/engine/img/www-icon.jpg)

## WWW

Стоит заметить, что набор доступных средств защиты зависит от конкретного семейства МК (F, G, L и H). Демонстрационные примеры в пакете X-CUBE-SBSFU охватывают большую часть из этого набора, но за полной информацией в любом случае следует обращаться к документации. Конкретно сегодня нас интересуют:

- [AN5156](https://www.st.com/content/ccc/resource/technical/document/application_note/group1/9f/0b/e4/b6/75/15/4f/e2/DM00493651/files/DM00493651.pdf/jcr:content/translations/en.DM00493651.pdf) — ключевой материал о безопасности микроконтроллеров STM32;
- [UM2262](https://www.st.com/content/ccc/resource/technical/document/user_manual/group0/33/ee/5b/6b/c7/43/44/3e/DM00414687/files/DM00414687.pdf/jcr:content/translations/en.DM00414687.pdf) — руководство по фреймворку SBSFU в пакете XCUBE;
- [AN4838](https://www.st.com/content/ccc/resource/technical/document/application_note/group0/bc/2d/f7/bd/fb/3f/48/47/DM00272912/files/DM00272912.pdf/jcr:content/translations/en.DM00272912.pdf) — апноут для MPU (Memory Protection Unit);
- [PM0253](https://www.st.com/content/ccc/resource/technical/document/programming_manual/group0/78/47/33/dd/30/37/4c/66/DM00237416/files/DM00237416.pdf/jcr:content/translations/en.DM00237416.pdf) — мануал по механизмам защиты для ядра Cortex-M7;
- [DS12110](https://www.st.com/resource/en/datasheet/dm00387108.pdf) — даташит на МК H743;
- [RM0443](https://www.st.com/content/ccc/resource/technical/document/reference_manual/group0/c9/a3/76/fa/55/46/45/fa/DM00314099/files/DM00314099.pdf/jcr:content/translations/en.DM00314099.pdf) — референс на МК H743.

Все ссылки — на PDF.

### Защита от чтения, RDP

Это базовый механизм безопасности, который предотвращает доступ к содержимому памяти микроконтроллера различными отладочными средствами (JTAG, SWV и ETM). Его применение рекомендуется во всех случаях на готовых серийных устройствах. Отключение RDP возможно только для первого уровня защиты и приводит к стиранию содержимого флеш-памяти. Включение второго уровня — необратимая операция для микросхемы.

Теоретически все это может осложнить сервисное обслуживание и поиск причины неисправности возвращенного пользователем оборудования. Однако, так как само приложение все равно сохраняет способность писать в постоянную память и изменять ее, возможность обновлений прошивки (в том числе с помощью SFU) остается. При включенном RDP попытка доступа к защищенному участку памяти приводит к генерации ошибки на шине AHB.

На H743 за эту функцию отвечают биты RDP `[15:8]` в паре регистров `FLASH_OPTSR_CUR` и `FLASH_OPTSR_PRG` из области Option Bytes. При этом значение `0xAA` соответствует нулевому уровню защиты (по умолчанию), значение `0xCC` — первому, а любое другое — второму (максимальному) уровню.

![](https://xakep.ru/wp-content/themes/engine/img/info-icon.jpg)

## INFO

Формально на диаграммах STMicroelectronics Option Bytes относятся к внутренней флеш-памяти, однако непосредственный доступ к ним невозможен. Для взаимодействия и внесения изменений пользователю нужно обращаться к регистрам и следовать определенной процедуре (подробнее см. раздел Option Bytes Modification на с. 157 RM0433).

### Защита от записи, WRP

Эта мера безопасности дополняет RDP и направлена не только на защиту содержимого флеш-памяти от внешних угроз (инъекция вредоносного кода и последующее его исполнение), но и от ошибочного выхода за границы массивов и переполнения буферов в пользовательских функциях. Простая в использовании, WRP также рекомендуется производителем в самых разных ситуациях.

Гибкость этого механизма позволяет защищать от записи как отдельные страницы, так и целые сектора памяти (подробнее см. в документации). Дополнительно перед включением WRP можно заполнить свободное пространство инструкциями NOP или WFI — лишним это точно не будет.

На H743 пользователю доступны 2 Мбайт флеш-памяти, которые разделены на два банка (по адресам `0x0800 0000` — `0x080F FFFF` и `0x0810 0000` — `0x081F FFFF` соответственно). Каждый банк, в свою очередь, разделен на восемь секторов по 128 Кбайт. За функцию WRP отвечают биты `[7:0]` в регистрах `FLASH_WPSN_XX`.

### Только исполнение, PCROP

Название этого аппаратного механизма может вводить в заблуждение. Действительно, первая часть заставляет вспомнить о Program Counter, тогда как вторая — ReadOut Protection — как будто уже встречалась и непонятно, чем отличается от рассмотренного выше RDP.

На самом деле Proprietary Code ReadOut Protection выполняет схожие функции, но если RDP блокировал несанкционированный доступ к памяти через отладочные интерфейсы микроконтроллеров, то PCROP защищает от более изощренных атак, нацеленных на кражу самой прошивки устройства через использование уязвимостей или ошибок в ПО.

Пометив с помощью регистров `FLASH_PRAR_PRGX` диапазон адресов во флеш-памяти флагом «только исполнение», разработчик может защитить интеллектуальную собственность своей компании (готовые библиотеки и куски кода) от копирования и обратной разработки. Содержимое флеш-памяти из такой области будет подаваться исключительно на шину инструкций процессора.

К сожалению, использование такой технологии на практике ведет к грануляции внутренней памяти: так, на нашей микросхеме H743 под PCROP в каждом банке памяти может быть выделена только одна область (итого — не более двух на микросхему). При этом область должна быть кратна размеру блока (256 байт) и выровнена по соответствующей границе.

### Безопасный доступ, SAO

Пожалуй, это одна из самых интересных функций защиты памяти на STM32. Настолько интересная, что производитель даже толком не смог определиться с ее названием: где-то в документации она обозначена как Secure User Memory (AN5156), где-то — как Secure Access Only (RM0443). А для серии G0/G4 это вообще Securable Area!

Если коротко — область памяти с безопасным доступом используется для создания унифицированного метода загрузки сразу после сигнала сброса. Такой код обладает исключительными правами на чтение, запись и исполнение в заданном диапазоне адресов. Изоляция от остальной части программы происходит при этом на аппаратном уровне.

SAO на STM32 предназначена в первую очередь для размещения Secure Boot и формирования цепочки доверия в системе. Именно здесь стоит хранить свои ключи и алгоритмы шифрования для проверки целостности и аутентификации образа основной прошивки перед передачей управления в основную программу. Как и для остальных механизмов защиты, за размещение SAO во флеше отвечают регистры в Option Bytes: `FLASH_SCAR_CURX` и `FLASH_SCAR_PRGX`.

![](https://xakep.ru/wp-content/themes/engine/img/warning-icon.jpg)

## WARNING

Работая с серией H7, не следует путать флеш-память с безопасным доступом (Secure) и системную память (System). Последняя всегда находится несколько «сбоку» от основного массива памяти (адреса с `0x1FF0 0000` по `0x1FF5 0000`). На всех схемах от STMicroelectronics область системной памяти в первом банке (которая служит для хранения кода DFU-загрузчика) помечена как Secure. Однако аналогичный свободный сектор во втором банке хоть и системный, но небезопасный (по умолчанию)! Кстати, фактически, это «лишние» 128 Кбайт, на которые ты всегда можешь рассчитывать.

### Блок защиты памяти, MPU

Рассмотренные механизмы безопасности обладают одним общим свойством: все они статичные, то есть жестко заданы на момент выполнения программы. Само по себе это нельзя отнести к недостаткам, однако использование в сложном проекте операционной системы с несколькими процессами неизбежно порождает необходимость динамического распределения прав доступа к тем или иным областям памяти. За это и отвечает MPU (Memory Protection Unit).

Блок защиты памяти относится к возможностям самого процессорного ядра, в нашем случае — Cortex-M7 (стоит заметить, что из всей линейки ARM Cortex-M лишь семейство M0 лишено MPU). Из этого вытекают следующие, вполне логичные рассуждения: MPU способен контролировать доступ к любому компоненту, так или иначе отображенному в адресное пространство процессора. Таким образом, мы можем использовать этот блок не только для очевидных вещей, вроде обеспечения безопасности ОЗУ и флеш-памяти, но и для ограничения прав на периферию: интерфейсы, регистры, что угодно.

Второе важное наблюдение: MPU контролирует CPU, но никак не DMA (Direct Memory Access, прямой доступ к памяти). А ведь они тоже могут быть ведущими на внутренних шинах микроконтроллера! К счастью, возможности DMA по сравнению с CPU сильно ограничены. За исключением, может быть, специализированного DMA2D (Chrom-ART). Существует ли на свете пример с эксплуатацией DMA2D для обхода MPU и компрометации реального устройства? Я не знаю, но дорого бы дал за то, чтобы взглянуть на подобное! ![🙂](https://s.w.org/images/core/emoji/14.0.0/svg/1f642.svg)

Наконец, следствие третье: документацию на блок защиты памяти следует искать никак не в референсе (и уж точно не в даташите) на микроконтроллер. Тут прямая дорога к руководству PM0253 на само ядро. Если раньше ты обходил этот материал стороной («Ну он же для системных программистов и разработчиков компиляторов!»), то теперь придется читать, ничего не поделаешь. Ну и конечно, сам апноут AN4838 по применению MPU тоже нужно знать.

### Обнаружение воздействия, Anti-Tamper

Следующий механизм защиты работает тоже в динамике, но уже не на уровне самого микроконтроллера или его ядра, а на уровне готового, законченного устройства. У разработчика есть возможность использовать специализированные выводы микросхемы, объединенные с областью малопотребляющей периферии (часы реального времени и резервная SRAM), для обнаружения попыток несанкционированного доступа к устройству. Например, вскрытие корпуса или аномально сильное воздействие («тяжелым тупым предметом», как это пишут в полицейских отчетах).

Как ты наверняка уже знаешь, на микроконтроллере H743 есть три области (domains), разделенные по быстродействию и энергопотреблению. В D1 расположено само ядро Cortex-M7, большая часть внутренней SRAM и самая скоростная периферия: FMC, LTDC, QSPI и прочее. В D2 работают стандартные интерфейсы: ETH, USB и MMC. А вот в D3 размещена та самая малопотребляющая периферия, которая сохраняет свою работоспособность даже при батарейном питании.

Таким образом, используя выводы Anti-Tamper МК, мы можем зафиксировать попытку взлома и аппаратно очистить регистры RTC и резервное ОЗУ в D3 со всеми хранившимися там секретами, даже если злоумышленник заблаговременно отключил устройство от основного питания! Это гарантирует, что конфиденциальная информация не попадет в чужие руки, а сервисное обслуживание легко выявит неладное.

### Сторожевой таймер, IWDG

Наконец, последний в нашем списке (но оттого ничуть не менее важный) механизм защиты — это независимый сторожевой таймер. Стандартно его используют для принудительной перезагрузки микроконтроллера, если программа столкнулась с критической ошибкой или ушла в бесконечный цикл.

Однако, поскольку IWDG тактируется от внутреннего LSI, это позволяет успешно сверяться с ним при выполнении критичных участков кода, которые могут стать первой целью преступников (различные АМИС по питанию, тактовому сигналу или ЭМИ). Кроме того, IWDG может принудительно перезагружать основной процессор, если тот не был вовремя проинициализирован (не выполнился загрузчик или не прошла установка обновления).

IWDG относится к базовой периферии и встречается на любом современном микроконтроллере. Неудивительно, что на Н743 он тоже присутствует.

### Внешний флеш

Перечисленные методы защиты МК рекомендуются производителем, и с необходимостью их применения трудно спорить (с учетом нынешних угроз «интернету вещей»). Однако особенно актуальной концепция Secure Boot и Secure Firmware Update становится при использовании внешней микросхемы флеш-памяти для хранения прошивки и пользовательских данных. Такие микроконтроллеры достаточно дешевы для своих возможностей. Например, [STM32H750](https://www.st.com/resource/en/datasheet/stm32h750zb.pdf) с частотой 480 МГц содержит всего 128 Кбайт памяти, но стоит при этом порядка 7 долларов. Его контроллер Quad SPI позволяет не только отображать внешний флеш в адресное пространство процессора, но и исполнять из него код практически без потерь в производительности.

## Криптография

Разобравшись с аппаратными компонентами защиты, рассмотрим теперь, как формируется образ пользовательской прошивки Secure Boot. Нам потребуется мануал UM2262.

На стороне сервера процесс выглядит следующим образом. Сперва по алгоритму SHA-256 рассчитывается хеш от итогового значения прошивки и помещается в заголовок. Далее генерируется пара ключей (приватный и публичный) на основе эллиптических кривых NIST P256 и подписывается бинарник (ECDSA). На финальном этапе заголовок и прошивка шифруются с помощью алгоритма AES CBC и получившийся файл вместе с IV отправляется пользователю для загрузки.

На стороне устройства последовательность действий выполняется в обратном порядке, с минимальными изменениями. Стоит заметить, что «из коробки» Secure Boot поддерживает следующие схемы:

- `SECBOOT_ECCDSA_WITHOUT_ENCRYPT_SHA256` (образ без шифрования, аутентификация ключом ECCDSA);
- `SECBOOT_ECCDSA_WITH_AES128_CBC_SHA256` (шифрование AES, аутентификация ключом ECCDSA);
- `SECBOOT_AES128_GCM_AES128_GCM_AES128_GCM` (шифрование AES, аутентификация симметричным ключом).

![](https://xakep.ru/wp-content/themes/engine/img/info-icon.jpg)

## INFO

Любопытная деталь — все алгоритмы шифрования в пакете Secure Boot реализованы программно, даже для тех микроконтроллеров, на борту которых имеются криптографические ускорители (блоки CRYP и HASH). Видимо, в STMicroelectronics работу со столь специфичной периферией оставляют на усмотрение пользователя.

### Пользовательская схема шифрования

При желании разработчик может реализовать работу Secure Boot с собственными алгоритмами. Для этого сперва нужно дать криптографической схеме произвольное название в виде определения в `SECoreBin/Inc/se_crypto_config.h`. Далее модифицируется описание заголовка пользовательской прошивки в `SECoreBin/Inc/se_def_metadata.h`, после чего предстоит реализовать функции в соответствии с интерфейсом загрузчика (см. `SECoreBin/Src/se_crypto_bootloader.c`).

Теперь остается только модифицировать скрипты `key.py`, `prepareimage.py` и `translate_key.py` соответствующим образом и интегрировать со своей средой разработки. Наиболее простой вариант — формирование файла `SECBOOT_CUSTOM.bat` совместно с `prebuild.bat` и `postbuild.bat`.

## Реализация для H743

Теперь, когда мы разобрались в основных компонентах Secure Boot, нам предстоит портировать базовый проект от ST на отладочную плату Nucleo-H743. Непосредственно для нашей отладки примера реализации в пакете нет, однако он существует для «старшего брата» — Н753. Эти микросхемы во многом идентичны, за исключением аппаратного криптографического ускорителя на Н753. Это важное отличие, но для наших сегодняшних целей оно некритично, так что возьмем Н743 в качестве основы.

Под нашу платформу в пакете есть две реализации, которые отличаются количеством слотов в памяти МК под актуальную прошивку (конфигурации с одним или двумя слотами). В свою очередь, каждая реализация содержит по три проекта.

![](https://xakep.ru/wp-content/themes/engine/img/www-icon.jpg)

## WWW

Все [исходные коды](https://www.st.com/content/st_com/en/products/embedded-software/mcu-mpu-embedded-software/stm32-embedded-software/stm32cube-expansion-packages/x-cube-sbsfu.html) доступны для скачивания на сайте ST. Там же следует искать и [утилиту](https://www.st.com/content/st_com/en/products/development-tools/software-development-tools/stm32-software-development-tools/stm32-programmers/stm32cubeprog.html) для прошивки и настройки MPU.

В опциях проекта желательно заменить макроопределение `STM32H753xx` на `STM32H743xx`, после чего нужно откомпилировать проекты в следующем порядке.

![](https://xakep.ru/wp-content/uploads/2019/12/257286/DEFINE.png)

### Image\_SECoreBin

Здесь находится реализация базовых криптографических функций. Необходимо указать схему в определении `SECBOOT_CRYPTO_SCHEME` — либо из готовых примеров производителя, либо пользовательское шифрование. Также следует задать приватный ключ в файлах `OEM_KEY_COMPANY1_key_AES_XXX.bin`. Далее при вызове скрипта `prebuild.sh` они сохраняются в двоичном виде в файле `se_key.s`.

![](https://xakep.ru/wp-content/uploads/2019/12/257286/SFU.png)

### Image\_SBSFU

Непосредственно загрузчик SBSFU, который также отвечает за функции безопасного обновления и предоставляет транспортный уровень (для базовых примеров это Y-MODEM). Именно загрузчик отвечает за подключение всех реализованных алгоритмов криптографии. Ядро Secure Boot линкуется в проект в виде библиотеки. Далее скомпилированный файл можно прошить в память микроконтроллера при помощи утилит STlink Utility или STM32CubeProgrammer.

### Image\_UserApp

Это базовый пример пользовательского приложения. В данном случае у нас есть простой текстовый интерфейс, который позволяет проверять защиту, выводить служебную информацию и перепрошивать устройство. При помощи `postbuild.sh` из скомпилированного файла формируется цифровая подпись `UserApp.sfb`, которую следует передать в наш загрузчик через Y-MODEM. SBSFU проверяет корректность подписи, после чего сохраняет ее в выделенной SAO памяти.

![](https://xakep.ru/wp-content/uploads/2019/12/257286/SecureBoot_success.png)

![](https://xakep.ru/wp-content/themes/engine/img/warning-icon.jpg)

## WARNING

Важный момент: в полноценном режиме проект SBSFU предполагает отключение средств отладки микроконтроллера. Для сброса PCROP и реконфигурации уровня RDP на отладочной плате нужно зажать кнопку Reset и в утилите STM32CubeProgrammer подключиться в режиме Connect under reset. Напомню, если изменить RDP, будет сброшена внутренняя флеш-память, в том числе удалены ключи шифрования.

### Прошивка и настройка Option Bytes

Наконец, нам предстоит самостоятельно выставить OB в нужный режим работы. Во-первых, переводим RDP на первый уровень защиты (см. описание выше). Далее указываем значения для PCROP и WRP по получившимся адресам в памяти. Все готово! Теперь при перезагрузке МК мы можем подключиться по терминалу (предоставляется отладочной платой в виде VCP) и прочитать приветствие от Secure Boot. Все стандартные средства безопасности от STMicroelectronics включены и работают в штатном режиме.

![](https://xakep.ru/wp-content/uploads/2019/12/257286/CustomBoot_Test_success.png)

![](https://xakep.ru/wp-content/themes/engine/img/info-icon.jpg)

## INFO

Если тебе и этого недостаточно, то можешь посмотреть в сторону более специфичных решений. Например, [STSAFE-A100](https://www.st.com/resource/en/datasheet/stsafe-a100.pdf) и [плата расширения](https://www.st.com/resource/en/data_brief/x-nucleo-stsa100.pdf) Nucleo на его основе. Для встраиваемых систем это почти как TPM для ПК. Однако учти, что данная штука под NDA и ST вряд ли расстанется с ней просто так. Но ты ведь наверняка что-то придумаешь? ![🙂](https://s.w.org/images/core/emoji/14.0.0/svg/1f642.svg)

## Заключение

Как ты уже понял, Secure Boot достаточно простой и удобный при портировании фреймворк, который позволяет реализовать загрузку и обновление прошивки в устройстве с минимумом ненужных телодвижений. Это заметно повысит защищенность устройства и заставит злоумышленников лишний раз усомниться в выборе цели.

Однако, разумеется, абсолютно безопасных решений не существует и даже тщательное следование всем рекомендациям производителя не гарантирует полного отсутствия уязвимостей. Физические устройства, как объекты реального мира, предоставляют значительно больше информации и способов взаимодействия, чем может показаться на первый взгляд.

Пытливый хакер может обойти даже эшелонированную оборону, воздействуя на микросхему ультрафиолетом, анализируя трассы энергопотребления или генерируя электромагнитные помехи специальным оборудованием. Но об этом как-нибудь в другой раз. До встречи!