#MCU #C #STM32

Содержание

1. [Подготовка](https://tech-geek.ru/overclock-memory-arduino-stm32/#podgotovka)
2. [Интерфейс памяти](https://tech-geek.ru/overclock-memory-arduino-stm32/#interfeys-pamyati)
3. [Настройка FMC](https://tech-geek.ru/overclock-memory-arduino-stm32/#nastroyka-fmc)
4. [Запускаем SDRAM](https://tech-geek.ru/overclock-memory-arduino-stm32/#zapuskaem-sdram)
5. [Правим ldscript](https://tech-geek.ru/overclock-memory-arduino-stm32/#pravim-ldscript)
6. [Реализуем sbrk](https://tech-geek.ru/overclock-memory-arduino-stm32/#realizuem-sbrk)
7. [Добавляем в main](https://tech-geek.ru/overclock-memory-arduino-stm32/#dobavlyaem-v-main)
8. [Заключение](https://tech-geek.ru/overclock-memory-arduino-stm32/#zaklyuchenie)

## Подготовка

Итак, нашей главной задачей будет размещение 8 Мбайт оперативной памяти в адресном пространстве процессора Cortex-M7. Да, я не ошибся — хоть у нас и 128 Мбит (16 Мбайт) во внешней микросхеме, но из-за того, что на плате разведена 16-битная шина данных (вместо максимально возможных 32 бит), нам по факту доступна только половина этого объема. Это, конечно, фигово, но тут уж ничего не поделаешь.

Начинать надо с поиска документации и знакомства с ней. Для удобства я уже собрал все необходимое в сноске ниже. На первый взгляд там в руководствах сотни страниц и осилить их едва ли возможно, но на практике это вовсе и не надо. Проверить адрес и описание регистров в одном месте, подсмотреть тайминги в другом, прочитать пару абзацев в третьем — вот, собственно, и все что нам нужно.

- [Документация на микроконтроллер DS10916](https://www.st.com/resource/en/datasheet/stm32f746ng.pdf)
- [Документация на микросхему памяти SDRAM](https://www.micron.com/-/media/client/global/documents/products/data-sheet/dram/128mb_x32_sdram.pdf)
- [Документация на плату UM1907](https://www.st.com/resource/en/user_manual/dm00190424.pdf)
- [Референс на микроконтроллер RM0385](https://www.st.com/resource/en/reference_manual/dm00124865.pdf)

Посмотрим, как выглядит адресное пространство на нашем микроконтроллере. Это восемь блоков по 512 Мбайт (итого 4 Гбайт — максимум для 32-разрядных процессоров). Системное ОЗУ располагается в первом блоке и занимает адреса с 0x20000000 по 0x2004FFFF, предоставляя в наше распоряжение 320 Кбайт статической памяти. Больше вы можете получить только с помощью FMC и внешней микросхемы. FMC работает с адресами из блоков с третьего по шестой, но подключить SDRAM можно только в два последних.

Я предлагаю разместить внешнюю память в пятом блоке. Так мы получим дополнительные 8 Мбайт по адресам с 0xC0000000 по 0xC07FFFFF. Периферийный блок FMC будет обрабатывать все запросы на доступ к памяти в этой области и по параллельной шине переправлять в микросхему SDRAM. В целом такое взаимодействие между ЦПУ и внешним ОЗУ почти ничем не отличается от работы с памятью на любом компьютере, телефоне или ноутбуке. Да, там все это гораздо шустрее и объемы существенно больше, но принципиальных отличий очень мало.

По существу, нам надо выполнить функции BIOS по инициализации аппаратной части и сделать ровно три вещи.

1. Во-первых, сконфигурировать выводы микроконтроллера для работы с параллельным интерфейсом.
2. Во-вторых, настроить FMC под нашу оперативную память (да, придется поиграться с таймингами).
3. В-третьих, загрузить регистр с параметрами работы в саму микросхему.

В итоге наша основная функция будет выглядеть примерно так:

|  | void xmem\_init() {    pin\_init();    fmc\_init();    sdram\_init();  } |
| --- | --- |

Осталось только последовательно написать реализацию для каждого этапа и органично вставить это куда-нибудь в код скетча.

## Интерфейс памяти

Прежде всего нужно определиться с физическим представлением нашего интерфейса памяти. У нас есть отдельные сигнальные линии для адресов (A\[25:0\]), данных (D\[32:0\]), команд (CAS, RAS, WE, CS) и тактирования (CLK, CKE). Дело несколько облегчается тем, что используется далеко не полный набор (про урезанную шину данных я уже упоминал), но и всего этого немало.

Схему подключения SDRAM к микроконтроллеру можно найти в документации на плату. Там же можно узнать, что для адресации используются 12 бит и еще два дополнительных бита указывают на один из четырех внутренних банков памяти в микросхеме. Для наглядности я свел все данные в небольшую табличку.

![разогнать оперативную память STM32 Arduino](https://tech-geek.ru/wp-content/uploads/overclock-memory-arduino-stm32-1.jpg?x10373)

Теперь остается только сконфигурировать все выводы GPIO для работы в альтернативном режиме с FMC.


```c
	#include "stm32f746xx.h" 
	static inline void pin_init() {    /* Enable clock for GPIO ports \*/    RCC -\ AHB1ENR |= RCC\_AHB1ENR_GPIOCEN | RCC\_AHB1ENR_GPIODEN |                      RCC\_AHB1ENR_GPIOEEN | RCC\_AHB1ENR_GPIOFEN |                      RCC\_AHB1ENR_GPIOGEN | RCC\_AHB1ENR_GPIOHEN;    
	/* Configure GPIO ports */    /* PC3: AF PP + VHS + AF12 */    
	GPIOC -> MODER   |= GPIO_MODER_MODER3_1;    
	GPIOC -> OSPEEDR |= GPIO_OSPEEDER_OSPEEDR3_1 | GPIO_OSPEEDER_OSPEEDR3_0;
	    GPIOC -> AFR[0]  |= GPIO_AFRL_AFRL3_3 | GPIO_AFRL_AFRL3_2;     
	}
```


|     |     |     |     |     |     |     |     |     |     |     |     |     |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

Здесь мы последовательно подаем тактирование на порты GPIO (без этого никак), затем для PC3 задаем режим работы, устанавливаем максимальную скорость и выбираем его в качестве вывода FMC. Остается только повторить операции выше для всех остальных сигналов.

Это самая нудная и примитивная часть всего процесса. Хуже того, ошибаться тут никак нельзя, поскольку заметить опечатку потом будет очень сложно. Так что я выделил код для всех оставшихся выводов в отдельном листинге.

## Настройка FMC

Следующим этапом надо будет сконфигурировать блок FMC для нашей микросхемы памяти. Большую часть необходимых параметров можно почерпнуть из даташита, но самое главное решение предстоит принимать самому. Конечно же, я говорю о тактовой частоте оперативной памяти. Именно она будет определять все остальные тайминги, и именно от нее будет зависеть итоговая производительность нашей системы.

По умолчанию FMC тактируется от частоты процессора — HCLK. Для F746NG максимальное значение составляет 216 МГц, и базовая настройка в скетче Arduino (до вызовов функций setup и loop) выставляет именно его. Конечно же, выбрать такую частоту для микросхемы памяти было бы слишком, ведь по документации она работает только вплоть до 167 МГц.

Поэтому блок FMC позволяет выбрать предделитель для частоты SDRAM. На выбор дается только два значения: /2 и /3. И это довольно неприятно, так как у нас есть дополнительное ограничение на максимальную частоту самого FMC и больше 100 МГц на нем выставлять вроде как нельзя. Но очень хочется!

![разогнать оперативную память Arduino](https://tech-geek.ru/wp-content/uploads/overclock-memory-arduino-stm32-2.jpg?x10373)

Что же делать — снижать частоту ядра до 200 МГц или выбирать делитель /3 и довольствоваться скромными 72 МГц на оперативной памяти? Конечно же, это все неправильные варианты. Следует разгонять, и разгонять по максимуму! Окей, звучит хорошо и самоуверенно, но на самом деле у нас очень хорошие шансы на успех, и я постараюсь кратко объяснить почему.

Работа любой микросхемы гарантируется ее производителем только в определенном диапазоне температур и напряжения питания (такую информацию всегда можно найти в даташите). Ключевое слово здесь — «гарантируется». Эти цифры — не уловки пиарщиков и маркетологов и эфемерные «+200% эффективности и скорости», которые замерили в идеальных условиях, а по факту в реальной жизни никто не увидит.

Нет, тут все серьезно. Перед тем как запустить микросхему в продажу, производитель проводит все необходимые тесты у себя в лабораториях, а главный инженер расписывается под результатами кровью. Ладно, про кровь я пошутил, но идею вы наверняка поняли.

У нас же почти «тепличные» условия использования для микросхемы — комнатная температура и стабильное напряжение на уровне 3,3 В. Как раз ровно посередине рекомендуемого диапазона 3,0–3,6 В. Так что все будет уверенно работать и на 108 МГц, еще и тайминги можно будет занизить.

> РЕКОМЕНДУЕМ:  
> [Espruino Pico: програмирование USB-микроконтроллера на JavaScript](https://tech-geek.ru/espruino-pico/)

Кстати, о таймингах. Теперь, когда известна тактовая частота, можно подсчитать длительность периода. Это примерно 9 нс, большая точность нам не требуется (несмотря на то что в секундах это цифра крохотная и в ней прилично нулей после запятой). И да, обратите внимание, у нас SDR (Single Data Rate) память, а не более привычная по миру персональных компьютеров DDR (Double Data Rate). Это значит, что синхронизация происходит только по одному фронту тактового сигнала вместо двух. Грубо говоря, в два раза медленнее при той же частоте.

Зная длительность периода, теперь легко вычислить величину всех нужных таймингов (для этого посмотрите таблицы 12 и 13 в даташите на микросхему памяти). Там, где их значение указывается в наносекундах, нужно подобрать такое количество тактов, чтобы их суммарная длительность была бы больше. Как пример — значение TXSR в таблице составляет 70 нс, а значит, надо указывать для него задержку в восемь тактов ( 8 х 9 \= 72 \> 70).

В общем, это не самая простая часть всей настройки, но в коде все выглядит вполне компактно (всего три записи в регистры).

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32 | static inline void fmc\_init() {    /\* Enable clock for FMC \*/    RCC \-\> AHB3ENR \|\= RCC\_AHB3ENR\_FMCEN;    /\* Configure Control Register:     \* 1. Use FIFO for Burst reads     \* 2. SDCLK is HCLK / 2 (108 MHz)     \* 3. CAS latency is 2 clock cycles     \* 4. Four internal banks     \* 5. Data bus width is 16 bits     \* 6. 4096 rows (12 bits)     \* 7. 256 columns (8 bits)     \*/    FMC\_Bank5\_6 \-\> SDCR\[0\]  \= FMC\_SDCR1\_RBURST \| FMC\_SDCR1\_SDCLK\_1 \|                              FMC\_SDCR1\_CAS\_1 \| FMC\_SDCR1\_NB \|                              FMC\_SDCR1\_MWID\_0 \| FMC\_SDCR1\_NR\_0;    /\* Configure Timing register:     \* 1. TRCD = 2 CLK cycles     \* 2. TRP = 2 CLK cycles     \* 3. TWR = 2 CLK cycles     \* 4. TRC = 7 CLK cycles     \* 5. TRAS = 5 CLK cycles     \* 6. TXSR = 8 CLK cycles     \* 7. TMRD = 2 CLK cycles     \*/    FMC\_Bank5\_6 \-\> SDTR\[0\]  \= FMC\_SDTR1\_TRCD\_0 \| FMC\_SDTR1\_TRP\_0 \|                              FMC\_SDTR1\_TWR\_0 \| FMC\_SDTR1\_TRC\_2 \|                              FMC\_SDTR1\_TRC\_1 \| FMC\_SDTR1\_TRAS\_2 \|                              FMC\_SDTR1\_TXSR\_2 \| FMC\_SDTR1\_TXSR\_1 \|                              FMC\_SDTR1\_TXSR\_0 \| FMC\_SDTR1\_TMRD\_0;  } |
| --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

> Мы потратили немало времени, листая даташит на память и выясняя, с какими настройками ее нужно запускать. Но откуда эту информацию берет обычный персональный компьютер, ведь там планки памяти — это практически plug & play?

Оказывается, помимо нескольких микросхем оперативной памяти, на каждой планке дополнительно присутствует энергонезависимая [SPD](https://en.wikipedia.org/wiki/Serial_presence_detect) EEPROM. Именно она хранит значения частоты и таймингов и сообщает их системе по последовательному интерфейсу [SMBus](https://en.wikipedia.org/wiki/System_Management_Bus) (аналог I2C).

В функции fmc\_init значения таймингов гарантированно рабочие и потому несколько завышены. Забегая вперед, скажу, что у меня получалось запустить плату с TRAS\=4 и TXSR\=7 без каких-либо ошибок. От знакомых слышал, что и это не предел и разгонять можно и дальше. Но уже разве что из спортивного интереса — особого прироста тут не получить.

## Запускаем SDRAM

Предыдущие две функции настраивали периферию только на самом контроллере. Теперь пришло время «пробудить» микросхему SDRAM и послать ей стартовые команды. Весь процесс детально описан на странице 35 документации на оперативную память. В коде это выглядит следующим образом:

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19  20  21  22  23  24  25  26  27  28  29  30  31  32  33  34  35  36  37  38  39  40  41  42  43  44 | #define CAS\_POS  (4)  #define CAS\_2    (2 << CAS\_POS)  #define CAS\_3    (3 << CAS\_POS)  #define MODE\_REG\_POS (9)  #define MODE\_REG     (CAS\_2 << MODE\_REG\_POS);  #define REFRESH\_RATE (1665)  static inline void sdram\_init() {    /\* Clock Configuration Command \*/    FMC\_Bank5\_6 \-\> SDCMR \= FMC\_SDCMR\_CTB1 \| FMC\_SDCMR\_MODE\_0;    while (FMC\_bank5\_6 \-\> SDSR & FMC\_SDSR\_BUSY) {      /\* wait until FMC is ready \*/    }    \_\_WFI(); /\* now wait until SDRAM is ready (~100 us) \*/    /\* Precharge All Command \*/    FMC\_Bank5\_6 \-\> SDCMR \= FMC\_SDCMR\_CTB1 \| FMC\_SDCMR\_MODE\_1;    while (FMC\_bank5\_6 \-\> SDSR & FMC\_SDSR\_BUSY) {      /\* wait until FMC is ready \*/    }    /\* Auto Refresh Command x4 \*/    FMC\_Bank5\_6 -> SDCMR = FMC\_SDCMR\_NRFS\_1 \| FMC\_SDCMR\_NRFS\_0 \|                           FMC\_SDCMR\_CTB1 \| FMC\_SDCMR\_MODE\_1 \|FMC\_SDCMR\_MODE\_0;    while (FMC\_bank5\_6 \-\> SDSR & FMC\_SDSR\_BUSY) {      /\* wait until FMC is ready \*/    }    /\* Load Mode Register Command (CL = 2) \*/    FMC\_Bank5\_6 -> SDCMR = MODE\_REG \| FMC\_SDCMR\_CTB1 \| FMC\_SDCMR\_MODE\_2;    while (FMC\_bank5\_6 \-\> SDSR & FMC\_SDSR\_BUSY) {      /\* wait until FMC is ready \*/    }    /\* Set Rrefresh Rate for SDRAM \*/    FMC\_Bank5\_6 -> SDRTR \|= REFRESH\_RATE << 1;  } |     |     |     |     |     |     |     |     |     |
| --------------------------------------------------------------------------------------------------------------------------------------------------------------------- | ------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- | --- | --- | --- | --- | --- | --- | --- | --- | --- |

Блок FMC выкинет на шину памяти несколько команд, среди которых нас больше всего интересуют ровно две: загрузка регистра режима (Mode Register) и таймера регенерации (Refresh Timer). Регистр режима выглядит так.

[![разогнать оперативную память stm32](https://tech-geek.ru/wp-content/uploads/overclock-memory-arduino-stm32-3.jpg?x10373)](https://tech-geek.ru/wp-content/uploads/overclock-memory-arduino-stm32-3.jpg?x10373)

Большинство комбинаций битов тут зарезервировано (очень интересно, зачем), а оставшиеся вполне можно оставить по умолчанию. Главное — не забыть выставить параметр CAS Latency, который определяет количество тактов между отправкой команды на чтение и появлением данных на шине.

Также следует указать, как часто данные в SDRAM нужно обновлять, ведь ячейки динамической памяти построены на основе конденсаторов и имеют свойство разряжаться со временем. Для этого сверимся с документацией на FMC (с. 379) и воспользуемся калькулятором.

![разогнать оперативную память stm32](https://tech-geek.ru/wp-content/uploads/overclock-memory-arduino-stm32-4.jpg?x10373)

Все, самое сложное теперь позади! Достаточно только вызывать функцию xmem\_init в setup и настроить SDRAM. С нашей микросхемой уже можно работать, и сейчас лучший момент проверить это, записав что-нибудь в память по новым адресам. Если не случилось никакого Bus Error (с экстраполяцией до Hard Fault), то примите мои заслуженные поздравления.

## Правим ldscript

Уже на этом этапе мы можем работать с внешней памятью примерно таким образом:

|     | #define BR\_IN\_SIZE    (0x2000)  #define BR\_OUT\_SIZE   (0x2000)  #define INPUT\_SIZE    (0x8000)  #define BUFFER\_SIZE   (0x8000)  #define BR\_IN\_OFFSET  (0xC00FF000)  #define BR\_OUT\_OFFSET (BR\_IN\_OFFSET + BR\_IN\_SIZE)  #define INPUT\_OFFSET  (BR\_OUT\_OFFSET + BR\_OUT\_SIZE)  #define BUFFER\_OFFSET (INPUT\_OFFSET + INPUT\_SIZE)  static uint8\_t \*const iobuf\_in   \= (uint8\_t \*const)BR\_IN\_OFFSET;  static uint8\_t \*const iobuf\_out  \= (uint8\_t \*const)BR\_OUT\_OFFSET;  static uint8\_t \*const input      \= (uint8\_t \*const)INPUT\_OFFSET;  static uint8\_t \*const buffer     \= (uint8\_t \*const)BUFFER\_OFFSET; |
| --- | --------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------------- |
|     |                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                           |

Это кусочек кода с буферами ввода-вывода для библиотеки bearSSL из моей предыдущей статьи. Так как операции с массивами — это частные случаи арифметики указателей, все реализуется достаточно просто. Однако такое использование памяти чревато проблемами — стоит только опечататься в адресах или размерах массивов, и следующие несколько часов придется потратить на исправление глупой ошибки.

Облегчить себе жизнь можно, если добавить в программу менеджер памяти. Или взять существующий. Вы наверняка уже догадались, что дальше речь пойдет о библиотечной функции malloc. Именно она возьмет на себя всю низкоуровневую работу с памятью и адресами, позволив нам сконцентрироваться на более важных вещах.

Изначально куча размещается в той же области внутренней SRAM, что и стек. Если получится перекинуть кучу во внешнюю память, то malloc начнет раздавать адреса оттуда. Это удобно, так как, во-первых, у нас освободится больше места под стек, во-вторых, менеджер памяти сможет нарезать нам кусочки целыми мегабайтами.

Для этого нам нужно добавить новую область памяти в скрипт загрузчика. В файлах Arduino по адресу packages/STM32/hardware/stm32/1.5.0/variants/DISCO\_746NG ищем ldscript.ld и открываем его в любом текстовом редакторе (исходную версию предварительно все же лучше сохранить). Перед секциями там указаны типы памяти в нашей системе. Исправляем на:

|  | /\* Specify the memory areas \*/  MEMORY  {    RAM (xrw)      : ORIGIN \= 0x20000000, LENGTH \= 320K    FLASH (rx)      : ORIGIN \= 0x8000000, LENGTH \= 1024K    SDRAM (xrw)     : ORIGIN \= 0xC0000000, LENGTH \= 8M  } |
| --- | --- |

После этого ищем описание секции user\_heap\_stack. Оно выглядит как-то так:

|  | /\* User\_heap\_stack section, used to check that there is enough RAM left \*/  .\_user\_heap\_stack :  {    . \= ALIGN(8);    PROVIDE ( end \= . );    PROVIDE ( \_end \= . );    . \= . + \_Min\_Heap\_Size;    . \= . + \_Min\_Stack\_Size;    . \= ALIGN(8);  } \>RAM |
| --- | --- |

Здесь происходит выравнивание данных по адресам в памяти и экспорт нескольких дополнительных переменных для компилятора. Это все уже не требуется, поэтому удаляем секцию полностью и пишем следующее:

|  | /\* User heap section \*/  .\_user\_heap :  {    PROVIDE ( \_heap\_min \= . );    PROVIDE ( \_heap\_max \= \_heap\_min + LENGTH(SDRAM));  } \>SDRAM |
| --- | --- |

Теперь куча будет размещаться во внешней микросхеме памяти, но нам еще нужно научить функцию malloc работать с новыми адресами. Править ее исходники было бы несколько опрометчиво (вот [здесь](https://github.com/lattera/glibc/blob/master/malloc/malloc.c) вы сможете оценить примерный масштаб проблемы), да это и не требуется. Мы зайдем с другой стороны и обратимся к функции sbrk, от которой зависит malloc.

## Реализуем sbrk

Сегодня вряд ли можно встретить человека, который порекомендует использование системного вызова [sbrk](https://en.wikipedia.org/wiki/Sbrk) в новых программах. Скорее наоборот, всячески посоветует держаться от него как можно дальше. Это разумно, это правильно, но во встраиваемых системах своя специфика, поэтому тут sbrk не только используют, но еще и правят от случая к случаю.

Прежде всего стоит взглянуть на файл syscalls.c, который можно найти по адресу packages/STM32/hardware/stm32/1.5.0/cores/arduino. Тут находится реализация sbrk по умолчанию, от нее и будем отталкиваться. Атрибут weak намекает, что в своих проектах эту функцию можно переопределять без последствий.

Создаем скетч в Arduino и добавляем новый файл sbrk.c. Пишем внутри:

| 1  2  3  4  5  6  7  8  9  10  11  12  13  14  15  16  17  18  19 | #include <sys/stat.h>  #include <errno.h>  extern char \_heap\_min;  extern char \_heap\_max;  extern int errno;  caddr\_t \_sbrk(int incr) {    static char \*current \= &\_heap\_min;    char \*previous \= current;    if (current + incr \> (char\*)&\_heap\_max) {      errno = ENOMEM;      return (caddr\_t) \-1;    }    current += incr;    return (caddr\_t) previous ;  } |
| --- | --- |

Теперь функция malloc из стандартной библиотеки будет зависеть уже от нашей реализации системного вызова. А мы сделали все для того, чтобы он раздавал адреса из нужного диапазона \[0xC0000000, 0xC07FFFFF\]. Последнее неудобство заключается в том, что в каждой нашей программе, которая использует внешнюю SDRAM, нам необходимо вызывать xmem\_init в setup перед динамическим распределением памяти. Иначе сказка закончится и карета превратится в тыкву значительно раньше полуночи. В смысле malloc вернет нулевой указатель, разумеется.

Об этом тяжело помнить каждый раз и очень легко забыть, поэтому проще будет вставить инициализацию памяти до того момента, как управление перейдет к пользовательскому коду.

## Добавляем в main

Проблема заключается в том, что функция main у нас одна для всех плат из пакета STM32duino, а Discovery F746 со своей внешней SDRAM в этом плане уникальна. Поэтому придется вводить дополнительные условия при компиляции скетча.

Снова идем по адресу packages/STM32/hardware/stm32/1.5.0/variants/DISCO\_746NG (в этой папке мы уже правили скрипт загрузчика). Открываем заголовочный файл платы variant.h и добавляем в любое место строчку с новым определением.

Далее переходим в папку packages/STM32/hardware/stm32/1.5.0/cores/arduino. Ищем main.cpp, в него предстоит внести заключительные изменения, чтобы все заработало. Во-первых, добавляем файл xmem.h с объявлением функции инициализации:

|  | #ifdef EX\_SDRAM    #include "xmem.h"  #endif |
| --- | --- |

И вставляем ее вызов прямо перед setup:

|  | #ifdef EX\_SDRAM    xmem\_init();  #endif |
| --- | --- |

Кстати, если вы обратите внимание на остальной код в main, то заметите, что конфигурация интерфейса USB на некоторых платах устроена по такому же принципу.

